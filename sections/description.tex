\chapter{Arhitectura sistemului}

În acest capitol vom construi arhitectura sistemului, astfel încât aceasta să își atingă scopul precizat anterior, ținând cont de proprietățile enumerate pe care soluția trebuie să le aibă. Pentru o descriere mai amplă și mai organizată a arhitecturii vom apela la metologiile clasice folosite în dezvoltarea arhitecturilor software.

\section{Părțile implicate}

Părțile implicate, sau \textit{stakeholderii} cum mai sunt numite acestea în literatură, sunt în număr de 3. Avem astfel dezvoltatorul sistemului de experimentare, clientul sistemului (dezvoltatorul aplicației principale) și utilizatorul final. Ne vom concentra în cele ce urmează pe ultimele două părți.

\textbf{\textit{Clientul sistemului}} este reprezentat de dezvoltatorul serviciului ce necesită efectuarea experimentelor. Astfel, acesta dorește să poată folosi cât mai ușor sistemul de experimentare, prin intermediul unui număr cât mai mare de limbaje de programare. Interesul acestuia este ca serviciul pe care lucrarea îl propune să fie cât mai flexibil și extensibil, pentru a oferi astfel acestuia posibilitatea de a fructifica cât mai multe oportunități, evitând adăugarea de complexitatea suplimentară a aplicației inițiale, prin gestionarea experimentelor în codul aplicației.

\textbf{\textit{Utilizatorul final}} este cel care utilizează aplicația principală. Acesta dorește ca aplicația să poată fi folosită rapid, iar acest lucru înseamna că serviciul pe care lucrarea îl propune nu trebuie să reprezinte un \textit{bottleneck}\footnote{O componentă ce încetinește întreg sistemul} pentru întreaga aplicație.

\subsection{Perspectiva funcțională}

Având părțile implicate definite, vom trece mai departe să definim perspectiva funcțională a fiecăreia dintre acestea.

\textbf{\textit{Clientul sistemului}} va dori să poată să adauge experimente, să șteargă experimente, și să poată vizualiza lista cu experimentele disponibile. Va putea de asemenea să definească lista cu valorile variabileleor pe care acestea le pot lua în cadrul unui experiment. De asemenea, în codul aplicației principale va dori să facă un apel cu parametrii identificatorul experimentului și identificatorul entității, și să obțină astfel toți parameterii variabileleor pentru toate experimentele în care se află entitate respectivă.

\textbf{\textbf{Utilizatorul final}}, fiind cel care va fi inclus în anumite experimente, dorește ca experiența sa să fie una cât mai uniformă în cadrul aplicației principale. Din acest lucru reiese ca sistemul de experimentare va trebui să mapaze în mod consistent o entitate în cadrul aceluiași grup dintr-un experiment. 

\section{Calități arhitecturale de sistem}

Vom prezenta în cele ce urmează calitățile arhitecturale de sistem ce sunt importante pentru sistemul pe care dorim să îl dezvoltăm. În același timp vom menționa tacticile și stilurile arhitecturale pe care le vom folosi pentru a implementa aceste calități.

\textbf{\textit{Adaptabilitatea}} este una din cele mai importante calități arhitecturale de sistem pentru un serviciu de experimentare. După cum am menționat anterior, considerăm vitală posibilitatea de a adăuga funcționalități foarte ușor la sistemul dezvoltat.

Pentru a putea satisface această calitate arhitecturală, vom folosi o serie de diverse tactici. Prima tactică este aceea de a efectua o abstractizare a modulelor sistemului astfel încât să existe cât mai puține dependențe între acestea. De asemenea vom folosi \textit{coerența semantică}, prin care fiecare modul va avea o funcționalitatea bine definită, iar relațiile între acestea vor fi definite riguros. Astfel, de fiecare dată când vom executa o modificare vom putea identifica toate modulele ce necesită modificări.

\textbf{\textit{Disponibilitatea}} este o alta calitate arhitecturală importantă. În orice aplicație modernă, experimentarea reprezintă un element primordial, aceasta regăsindu-se atât pe partea de \textit{frontend} cât și pe partea de \textit{backend}. De aceea trebuie ca serviciul de experimentare să fie disponibil cât mai mult timp, și să se limiteze  perioada de \textit{downtime}\footnote{Durata de timp în care sistemul nu este disponibil.}.

Tactica pe care o vom folosi este aceea de a dezvolta o arhitectură distribuită, astfel încât să evităm existentă unui \textit{single point of failure}\footnote{O componentă a sistemului care în caz de eroare compromite întreg sistemul}. Detectarea erorilor se va face folosind o tactică de tipul \textit{heartbeat}, în care vom verifica periodic starea unei componente a sistemului. Astfel, fiecare modul al aplicației, identificat anterior, în cazul în care nu va funcționa nu va compromite sistemul, deoarece responsabilitățile acestuia vor fi preluate de un alt modul identic ce va funcționa pe o altă mașină.

\textbf{\textit{Scalabilitatea}} sistemului este esențială. Ne dorim ca produsul să poată fi folosit atât de companii mici, \textit{start-up-uri}, dar și de companii mai mari, iar acest lucru presupune posibilitatea de a rula sistemul pe o gamă variată de resurse. Prin rularea distribuită, vom putea scala sistemul pe orizontală, prin adăugarea de mai multe servere, evitând astfel scalarea pe verticală, ce presupune mărirea resurselor mașinilor pe care este rulată aplicația, acest lucru fiind foarte costisitor.

\textbf{\textit{Performanța}} reprezintă o calitate arhitecturală pe care trebuie să o urmărim cu atenție. Pentru a obține o performanță cât mai bună, vom folosi tactica gestionării resurselor, introducând concurența în interiorul sistemului. Având în vedere faptul că vom avea foarte multe cereri către sistem, ce vor trebui rezolvate în același timp, este natural să urmăm o astfel de tactică.  

%TODO: Senariu QA ?! 

\section{Stilul arhitectural}

Pentru a putea îndeplini toate calitățile arhitecturale enumerate anterior, vom examina o suită de stiluri arhitecturale, pentru a putea observa care dintre acestea este mai potrivit pentru un sistem de experimentare. În mod evident, stilurile arhitecturale de tipul \textit{data-flow} sau \textit{batch-processing} nu se pliază cerințelor sistemului, întrucât experimentele trebuie să poată fi adăugate sau șterse cu ușurință, oferind o velocitate crescută. Se observă faptul că un sistem de tipul client-server este cel mai indicat pentru a fi folosit în situația de față. Cu toate acestea, după cum am menționat anterior, dorim să oferim posibilitatea clienților de a extinde foarte ușor sistemul de experimentare, pentru a-l particulariza conform cerințelor acestora. Acest lucru însă nu este foarte ușor de realizat, mai ales în condițiile în care aplicație este dezvoltată sub forma unui monolit.

Calitățile arhitecturale expuse, dar și scopul sistemului, ne îndrumă către o arhitectură bazată pe servicii. In mod imediat, abordarea clasică pe care o putem urma este aceea de \textit{SOA}\footnote{Service Oriented Architecture - Arhitectură orientată pe servicii}. Aceast tip de arhitectură are însă dezavantajul de a fi destul de complexă, iar în final modulele componente nu devin independente, ci autonome. De aceea, lucrarea propune o abordare arhitecturală mai nouă, bazată pe \textbf{\textit{microservicii}}.\cite{buildingmicro} 

\subsection{Arhitectura bazată pe microservicii}

Arhitecturile bazate pe microservicii reprezintă un nou mod de abordare a aplicațiilor, care se diferențiază segmentarea fiecărui modul al aplicației într-un serviciu independent. Aceste servicii pot comunica prin intermediul unui mecanism ce presupune un \textit{overhead} minimal, de obicei acest mecanism fiind protocolul HTTP\cite{onmicro}. Motivația principală ce stă la baza acestei arhitecturi constă în posibilitatea de a pune în producție fiecare dintre aceste servicii indepdent de celelalte, iar acest lucru duce la o viteză crescută de dezvoltare.

Unul din motivele pentru care microserviciile au reușit să fie adoptate de un număr relativ mare de companii, printre care menționăm \textit{Google}, \textit{Amazon} și \textit{Netflix}, într-un timp atât de scurt, se datorează și apariției tehnologiilor noi precum \textit{Docker}, ce permit rularea unei aplicații în interiorul unui \textit{container}, complet izolat de restul aplicațiilor de pe aceeași mașină. Prin container înțelegem un strat de abstractizare, superior din punctul de vedere al performanței față de mașinile virtuale. Astfel un \textit{container} încapsulează toate dependențele necesare unei aplicații, dar împarte același \textit{kernel} al sistemului de operare cu restul containerelor. 

\subsubsection{Avantaje}

Spre deosebire de aplicațiile clasice ce tip monolit, acest tip de aplicații distribuite au un avantaj foarte interesant, ce provine din faptul că fiecare serviciu component al său poate fi scris în orice limbaj de programare, atât timp cât poate efectua comunicarea cu restul serviciilor. Ca o consecință naturală, acest fapt oferă o flexibilitate mult mai mare dezvoltatorilor, conferind libertatea de a alege mult mai ușor tehnologie aparte ce se pliază problemei particulare pe care dorește să o rezolve serviciul. Implicit, prin fragmentarea aplicației se pot efectua mult mai ușor și tranzițiile către alte tehnologii, lucru ce este foarte greu, sau de mult ori imposibil de efectuat în contextul unei aplicații monolotice, unde se folosește aceeași tehnologie pentru întregul sistem.

Un alt avantaj evident este reprezentat de ușurința de a scala foarte ușor o platformă bazată pe microservicii. Acest lucru se poate realiza prin rularea a multiple instanțe ale unui serviciu, în spatele unui \textit{load-balancer}. Din nou se poate observa cum fracționarea sistemului conduce către o flexibilitate sporită, pe care o aplicație clasică nu o poate oferi. Posibilitatea de a scala doar componentele necesare reduc costul de rulare a aplicației.

Compunerea serviciilor este un alt aspect interesant, ce este facilitat de acest tip de arhitectură. De exemplu, tot mai multe aplicații trebuie să ofere o experiența unitară, pe mai multe platforme, ce permite utilizatorilor să schimbe platforma în mijlocul unei sesiuni de lucru. Prin segmentarea corectă a aplicației se vor putea compune serviciile pentru a reutiliza serviciile necesare pentru toți clienții, în timp ce va exista posibilitatea de dezvoltare a unor servicii specializate pentru tipuri particulare de platforme. 

Nu în ultimul rând trebuie amintită viteza de dezvoltare și de punere în producție a sistemului ce este una cu mult superioară față de aplicațiile clasice, monolitice. După cum am menționat anterior, fiecare serviciu este dezvoltat și lansat în mod independent fața de celelalte. Acest fapt oferă posibilitatea de a scala dezvoltarea aplicației prin descentralizarea acesteia. Fiecare serviciu nu va depinde de celelalte, iar acest fapt îmbunătățesc efectele unor metodologii de iterare rapidă precum integrarea continuă.

\subsubsection{Dezavantaje}

Desigur, pe lângă avantajele evidente, menționate anterior, există și o serie de dezavantaje pe care arhitectura bazată pe microservicii le prezintă\cite{onmicro}. Primul dezavantaj evident este acela al complexitații necesare punerii în producție a fiecărui serviciu, în mod individual, și orchestarea tuturor serviciilor ca un ansamblu. Există însă o întreagă suită de servicii ce orchestrare ce vin în ajutorul dezvoltatorilor pentru a putea minimiza această complexitate, precum \textit{Kubernetes}, dezvoltată de \textit{Google}.

Complexitatea sistemelor distribuite, de care un dezvoltatorii trebuie să țină cont, reprezintă un aspect dificil ar arhitecturii bazate pe microservicii. 

Deși împărțirea aplicației în microservicii duce la ușurarea procesului de testare a fiecărui serviciu, apare o altă problemă și anume aceea a efecutării testării \textit{end-to-end}, sau de integrare, a întregului sistem.

\subsubsection{Concluzie}

Deși prezintă o serie de dezavantaje, lucrarea consideră ca stilul arhitectural bazat pe \textit{microservicii} se pliază cel mai bine pentru un sistem de exeperimentare. Flexibilitatea și extensibilitatea sporită ce sunt oferite de o astfel de arhitectură fața de cele tradiționale, recomandă aceast stil.

\section{Principii arhitecturale}

În secțiunea anterioară am stabilit faptul că vom folosi o arhitectură bazată pe microservicii. În cele ce urmează vom defini un set de principii pe care le vom adopta în dezvoltarea arhitecturii sistemului, împreună cu motivația pentru alegerea acestora. Prin stabilirea acestor principii ne vom ușura misiunea de a segmenta serviciul de experimentare, acest lucru fiind cel mai important și totodatată dificil pas în elaborarea arhitecturii.

\subsubsection{Servicii \textit{stateless}}

Vom impune regula ca toate serviciile să fie considerate \textit{stateless}. Prin acest lucru înțelegem că acestea nu vor încapsula informații legate la starea aplicației. Astfel, în mod teoretic, scalarea serviciului pe orizontală se poate face prin simpla rulare a mai multor instanțe a acestuia. Această regulă sugerează de altfel REST ca și protocol de comunicare între servicii, de altfel acesta fiind protocolul folosit cel mai des în acest tip de arhitectură. \cite{buildingmicro}

\subsubsection{Separarea datelor}

Principiul separării datelor impune tuturor microserviciilor să folosească propria bază de date. Astfel, fiecare microserviciu va alege tipul de bază de date care este cel mai potrivit pentru acest, de exemplu un RDBMS sau o bază de date No-SQL. De asemenea, folosirea unei baze date date comune ar duce la dependențe între microservicii, provocate de folosirea comună a aceleași schema a bazei de date. Astfel, daca un serviciu solicită modificarea acesteia și restul serviciilor care o folosesc vor trebui să fie actualizate, și astfel pierdem din flexibilitatea arhitecturii microserviciilor. Pe de altă parte există posibilitatea de a avea inconsistențe între diferitele baze de date. Pentru soluționarea acestei probleme există așa numitele unelte \textit{Master Data Management}.

\subsubsection{Asocierea serviciu-\textit{container}}

În ceea ce privește modul de rulare a sistemului, există câteva soluții existente. Prima dintre acestea este maparea unui serviciu pe o mașină. Este evident că această strategie este una costisitoare, și nefazabilă pentru companiile mici. O altă soluționare vine din mapare unui serviciu pe o mașină virtuală, dar și această soluție este defectuoasă, deoarece gestionarea mașinilor virtuale reprezintă un proces complex. În final, vom apela la strategia ce presupune maparea unui serviciu în interiorul unui container de Linux. Astfel, vom putea multiplexa multiple servicii pe un număr limitat de mașini prin intermediul unor unelte de orchestrare, cum ar fi \textit{Kubernetes}.

\subsubsection{Expunerea unui API}

Din cauza faptului că arhitectura cu microservicii este foarte flexibilă, pot apărea dificultăți în gestionarea comunicării clientului cu sistemul, fiecare apel trebuind să fie făcut către serviciul corespunzător. Gestionarea unor astfel de apeluri însă nu este recomandată să aibă loc pe partea de client, pentru acesta fiind ideală comunicarea simplă sub forma unui API\footnote{Application Programming Interface}. Soluția acestor probleme vine din adăugarea unei alte componente și anume un \textit{API Gateway} sau un \textit{Reverse Proxy}. Clientul va face astfel mereu apelul către această componentă, care va ruta cererea mai departe serviciului corespunzător. Dezavantajul este acela că se adaugă complexitatea a încă unei componente la sistem, dar lucrarea consideră acest \textit{trade-off} ca fiind benefic. 

\section{Dezvoltarea arhitecturii}

În această secțiune vom descrie și vom construi gradual arhitectura sistemului de experimentare pe care lucrarea îl propune, conformându-ne principiilor enunțate anterior.

\subsection{Identificarea serviciilor}

Vom începe natural pentru arhitectura bazată pe microservicii, indentificând componentele sistemului. După cum am descris anterior, clientul sistemului de experimentare dorește să poată gestiona rapid adăugarea și ștergerea experimentelor. Astfel, conform principiului de separare a datelor, putem identifica un prim serviciu, acela de \textbf{\textit{Repository}}, sau \textit{Magazia Experimentelor}. Responsabilitatea acestei componente va fi gestionarea experimentelor, acesta având o bază de date asociată. 

Pe lângă componenta identificată deja, avem nevoie de un mecanism de asignare a unei entități către un experiment. O primă idee, intuitivă, spune că putem avea o componentă care va interoga magazia experimentelor și efectua apoi toate sarcinile necesare. Dar, deoarece știm ca dorim să experimentăm, cu mai multe astfel de modalități de asignare a entităților către experimente, și dorim de asemenea ca și clientul aplicației să poată folosi orice abordare dorește acesta, vom avea o componentă separată ce se va ocupa doar de acest lucru, pe care o vom numi \textit{\textbf{Assigner}}. Aceast serviciu se va ocupa exclusiv de gestionarea apratenenței unei entități la id-ul unui grup.

Ne amintim că din perspectiva funcțională a clientului final, acesta dorește ca experiența sa să fie cât mai uniformă. Acest lucru se traduce prin asignarea de fiecare dată a unei entități către aceleași grupuri din anumite experimente. Efectul poate fi obținut prin construcția unui \textit{Assigner} care este determinist. Dar, având în vedere că nu putem forța acest comporatament componentei respective, va trebui să construim o altă componentă, care să stocheze informații referitoare la asignarea inițială a unui utilizator, pe care o vom numi \textit{\textbf{Store}} Astfel, dacă acesta a fost deja asignat unui grup va trebui ca sistemul de experimentare să garanteze că a doua oară când va fi interogat, pentru aceeași entitate, va oferi același răspuns.

\begin{remark}
	Dacă serviciul Assigner este determinist atunci nu este necesară existența serviciului Store. 
\end{remark}

Nu în ultimul rând, avem nevoie de un serviciu care să coordoneze si să orchestreze interacțiunile între restul serviciilor, acesta fiind punctul ce va expune un \textit{API} pentru clientul aplicației. Vom denumi acest serviciu ca fiind \textit{\textbf{Experimento}}, acesta luând numele framework-ului de experimente pe care lucrarea îl propune. 

Am indetificat deci 4 microservicii ce vor fi nelipisite din alcătuirea sistemului de bază. Le vom recapitula sumar, pentru a le putea vizualiza ușor.

\begin{itemize}
	\item \textbf{Repository:} Gestionează experimentele
	\item \textbf{Assigner:} Assignează o anumită entitate unui grup dintr-un experiment
	\item \textbf{Store:} Reține asignarea inițială a unui utilizator
	\item \textbf{Experimento:} Serviciul principal, care expune \textit{API-ul} serviciului 
\end{itemize}

\begin{remark}
	Serviciul \textit{Experimento} reprezintă componenta centrală a sistemului, iar dezvoltarea corectă a acestuia este critică.
\end{remark}

\subsection{Descrierea mesajelor}

Într-o arhiectură bazată pe microservicii este foarte importantă comunicarea ce se realizează între componente. De aceea, soluția naturală este aceea de a standardiza mesajele, și a comunica folosind un anumit format, pentru a evita posibilele discrepanțe.

Deși există un număr mare de librării ce sunt folosite pentru serializarea și deserializarea mesjaelor, cât și pentru efectuarea de apeluri de tip \textit{RPC}\footnote{Remote procedure call}, precum \textit{Protocol Buffers}, \textit{Apache Thrift}, \textit{Message Pack}, ș.a.m.d, toate acestea folosind un format binar, de multe ori alegerea \textit{de facto} este aceea a mesajelor de tip JSON. În cele ce urmează vom încerca să definim mesajele pe care le vom folosi pentru comunicare într-un mod cât mai simplu, astfel încât să putem implementa această structură folosind oricare din bibliotecile menționate anterior. Sintaxa în care vom descrie structurile este aceea a limbajului de programare \textit{Go}.

Mesajul principal ce va sta la baza sistemului de experimentarea este acela ce va descrie complet un experiment. Va trebui să încapsulăm informații referitoare la variabilele experimentului, grupurile acestuia, dar și alte informații auxiliare. Acesta va avea următoarea structură:

\begin{center}
	\begin{lstlisting}[language=Golang]
type Description struct {
Info              // Informatii generale
Started time.Time // Startul experimentului

VariablesInfo map[string]VariableOptions
Groups        map[string]GroupDescription
Whitelist     map[string]string
}
	\end{lstlisting}
\end{center}

Se identifică trei mesaje ce vor trebui definite: \textit{Info}, \textit{VariableOptions}, alături de \textit{GroupDescription}.
\begin{center}
	\begin{lstlisting}[language=Golang]
type Info struct {
ID        string  // indetificatorul unui experiment
SeedValue string  // valoarea seed-ului
Size      float64 // dimensiunea experimentului
}
	\end{lstlisting}
\end{center}

\begin{remark}
	Câmpul \textbf{SeedValue} este folosit pentru a putea controla replicabilitatea rezultatelor unui experiment, în timp ce câmpul \textbf{Size} va avea o valoare între 0 și 1, ce va reprezenta fracția entităților ce va lua parte la experiment.
\end{remark}

\begin{lstlisting}[language=Golang]
type VariableOptions []string
\end{lstlisting}

Vom exprima lista de posibile alegeri ale unei variabile ca un vector de șiruri de caractere. Am ales această abordare deoarece ea este foarte simplă, și minimizează efortul necesar elaborării și înțelegerii unui experiment.

\begin{center}
	\begin{lstlisting}[language=Golang]
type GroupDescription struct {
StartSize float64
Variables map[string]string
}
	\end{lstlisting}
\end{center}

Deoarece, imediat cum un experiment a fost adăugat, nu există informații \textit{a priori}, va trebui ca pentru un experiment, indiferent de ce \textit{Assigner} va fi folosit pentru acesta, să specifice dimensiunea de început a grupului, prin intermediul câmpului \textit{StartSize}. Aceasta are rol orientativ, pentru a știi modul de asignare a entităților către anumite experimenete, atunci când nu există alte informații. De asemenea, această informație poate fi folosită și atunci când un assigner folosește un mecanism de tip \textit{holdout}, pentru a determina distribuția entităților ce fac parte din acesta. De aceea, va trebui ca suma acestui câmp peste toate grupurile experimentului să fie egală cu 1.

Câmpul \textit{Variables} asociează fiecărei variabile o anumită valoare pentru aceasta. Menționăm că trebuie efectuată verificarea astfel încât valoarea variabilei să fie validă, adică specificată anterior în \textit{VariableOptions}.


\subsection{Definirea interfețelor}

Fiecare din microserviiciile identificate a fost descris din punct de vedere funcțional, explicând rolul și cerințele acestuia. Framework-ul pe care lucrarea dorește șa îl dezvolte va propune o implementarea concretă pentru micro-serviciul \textit{Experimento}, unică. Pentru celelalte trei microservicii indentificate, le vom descrie sub forma unor interfețe. Vom dezvolta mai apoi o serie de implmenetări concrete pentru acestea. În definierea metodelor, ne vom folosi de mesajele definite anterior, ce vor fi standardizate pe parcursul aplicației, în descrierea interfețelor.

\begin{remark}
	Vom încerca să definim interfețele într-un mod cât mai minimal, pentru a putea oferi o flexibilitatea mare programatorului.
\end{remark}

\subsubsection{Repository}

Deși responsabilitatea principală a microserviciului \textit{Repository} este aceea de a gestiona experimentele, nu vom include în această interfața metode referitoare la aceste acțiuni. Motivul principal este acela de a oferi utilizatorilor serviciului o flexibilitatea cât mai mare în a-și scrie propriul lor microserviciu pentru gestiunea experimentelor. Astfel, singura metodă pe care interfața \textit{Repository} va trebui să o implementeze este aceea care oferă lista tuturor experimentelor active. Motivul este acela că microserviciul \textit{Experimento} va avea nevoie de aceasta pentru a putea întoarce valorile variabilelor pentru toate experimentele unei entități. Dorim această abordare de a obține toate valorile experimentelor în \textit{batch} pentru a putea evita suprasolicitarea serviciului de experimentare. Rămâne astfel datoria clientului să updateze în mod regulat lista cu experimentele din care face parte clientul. 


\begin{center}
	\begin{lstlisting}[language=Golang]
type Repository interface {
   GetExperiments() (map[string]Description, serror)
}
	\end{lstlisting}
\end{center}

\begin{remark}
	Metoda \textit{GetExperiements} trebuie să fie \textbf{thread-safe}\footnote{Să poată fi accesată simultan de mai multe thread-uri}, deoarece natura concurentă a serviciului obligă la apeluri concurente.
\end{remark}

În cazul în care nu a putut fi obținută lista experimentelor active, este necesar ca metoda să întoarcă o eroare, pentru a semnala componentei centrale \textit{Experimento} acest lucru. Ea va prelua apoi responsabilitatea gestionării erorii.

\subsubsection{Store}

Cum microserviciul \textit{Store} este responsabil pentru a reține asignarea unei entități către un experiment, vom expune două metode ale interfeței, una pentru a seta alegerea inițiala și alta pentru a interoga existența unei astfel de alegeri. Acestea vor trebui să primească ca parametru identificatorul entintății, și identificatorul experimentului, iar cea de \textit{set}, pe lângă acestea va primi ca parametru și grupul unde a fost asignată entitatea.

\begin{center}
	\begin{lstlisting}[language=Golang]
type Store interface {
   SetExperimentGroup(entityID, expID, group string) error
   GetExperimentGroup(entityID, expID string) (string, error)
}
	\end{lstlisting}
\end{center}

\subsubsection{Assigner}

Microserviciul \textit{Assigner} este foarte important, deoarece diferite implementări ale acestuia vor rezulta în diferite comportamente ale sistemului de experimentare. Vom folosi o singură metodă în această interfață ce va primi ca parametrii identificatorul entității, iar mai apoi întreaga descriere a unui experiment. Metoda va returna un șir de caractere ce va corespunde id-ului unui grup din cadrul experimentului, acest fiind grupul către care entitatea va fi asignată.

\begin{center}
	\begin{lstlisting}[language=Golang]
type Assigner interface {
  AssignGroup(entityID string, d Description) (string, error)
}
	\end{lstlisting}
\end{center}

\begin{remark}
	Metoda \textbf{AssignGroup} nu trebuie să fie determinstă.
\end{remark}

\begin{remark}
	Metoda \textbf{AssignGroup} trebuie să fie thread-safe.
\end{remark}

\subsubsection{Experimento}

Deși serviciul \textit{Experimento}, după cum am precizat anterior, nu va fi implementat prin intermediul unei interfețe, vom descrie interogările pe care un client le poate face către acest serviciu, fie printr-un mecanism de tip \textit{REST} sau \textit{RPC}, cu ajutorul următorei signaturi:

\begin{center}
	\begin{lstlisting}[language=Golang]
func GetAllVariables(entityID string) (Variables, error)
	\end{lstlisting}
\end{center}

După cum se poate observa, vom expune posibilitatea de a interoga variabilele tuturor experimentelor din care face parte un utilizator. Motivul pentru care impunem această restricție, și nu oferim posibilitatea interogării variabilelor pentru un experiment punctual, este aceea de a forța clientul să implementeze un mecanism de \textit{caching}, tocmai pentru a reduce încărcarea asupra serviciului de experimentare.

\begin{remark}
	Este responsabilitatea clientului să determine valoarea de timp după care va invalida rezultatele variabilelor.
\end{remark}

\subsection{Îmbunătățirea performanțelor}

După cum am văzut, arhitectura serviciul este făcută de o natură ce facilitează scalarea sistemului pe orizontală. Putem însă îmbunătăți  performanța serviciul, printr-un mecanism eficient de gestionare a resurselor. Acest lucru se poate obține fie prin introducerea paralelismului în sistem, fie prin introducerea concurenței în sistem. 

Sistemele bazate pe o arhitectură cu microservicii, au o natură concurentă, cauzată de multiplele comunicări ce trebuie efectuate între servicii. Acest fapt, coraborat cu natura dinamică a unui serviciu de experimentare, ce presupune operații de gestionare a experimentelor, executate simultan cu operații de interogare a variabilelor ne indică mecanismul pe care îl putem utiliza. De aceea vom introduce \textbf{concurența} în serviciul pe care îl vom dezvolta. Mecanismul de concurență pe care îl vom folosi este acela implementat de limbajul de programare \textit{Go}, și este inspirat de către lucrarea \textit{Communicating Sequential Processing}\cite{hoare_csp}. De aceea, algoritmii pentru un microserviciu vor folosi mecanisme precum \textit{canale} pentru a implementa concurența.

\subsection{Sistemul final}

Pentru a exemplifca modul în care funcționează întreg sistemul de experimentare, dar șî pentru a ilustra cum comunică componentele vom reprezenta grafic procesul ce are loc atunci când serviciul este interogat. Menționăm faptul că alte facilități pe care sistemul le va implementa, precum adăugarea și eliminarea de servicii sunt triviale, și de aceea ne vom concentra atenția asupra acestui aspect. 